백업 프로그램
===============
210207
-------------

## 명세 설명 중 공부

### 1. 스레드(Thread)의 개념 :

- 어떤 프로그램에서 프로세스가 실행되는 흐름의 단위 의미.

- 프로세스는 적어도 하나의 스레드를 가지고 있고, 우리가 흔히 알고 있는 main 함수 역시 스레드라고 할 수 있음.

- 멀티 프로세스 vs 멀티 스레드 : 흐름이 동시에 진행된다는 것에서 공통점이 있음. 프로세스와는 다르게 스레드는 메모리를 공유한다는 차이점이 있음.

- 헤더파일로 `#include <pthread.h>`를 선언하여 사용.

- 기본적으로 thread를 사용하는 데 쓰이는 함수로는 `pthread_create`, `pthread_join`, `pthread_detach`,`pthread_exit`, `pthread_cleanup_push`, `pthread_self` 등이 있다.

### 2. 기본 Thread 함수(대부분 사용 예정인 것들로 공부) :

* Thread의 생성을 위해 사용하는 함수 :
	- `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(start_routine) (void *), void *arg);`
	- `thread` = 성공적으로 함수가 호출되면 이곳에 thread ID가 저장됨.
	- `attr` = 스레드의 특성을 정의. 기본적으로 `NULL` 지정. 만약 스레드의 속성을 지정하려고 한다면 `pthread_attr_init`등의 함수로 초기화해야 함.
	- `start_routine` = 어떤 로직을 할지 함수 포인터를 매개변수로 받음.
	- `arg` = `start_routine`에 전달될 인자를 말함. `start_routine`에서 이 인자를 변환해 사용.
	- 성공했을 때, `thread`를 초기화함과 동시에 0을 반환. 실패 시 `thread`인자가 설정되지 않고 에러값을 반환.

* 생성한 Thread가 끝날 때까지 기다려주는 함수 :
	- 만약 `thread`가 이미 종료되었다면 즉시 리턴
	- `int pthread_join(pthread_t thread, void **retval)';`
	- `thread` = 우리가 join하려고 하는 thread 명시
	- `retval` = `pthread_create`에서 `start_routine`이 반환하는 반환값 저장
	- 성공적으로 호출되면 0 반환. 실패 시 에러 넘버를 반환. 실패 시에는 '좀비 스레드'가 되고 이 좀비 스레드는 자원을 소모하게 되어 더이상 스레드를 생성할 수 없음.

* Thread가 독립적으로 동작하게 하고 Thread가 끝나면 자원을 반환하는 함수 :
	- `int pthread_detach(pthread_t thread);`
	- 때에 따라서 스레드가 독립적으로 동작하게 하고(`pthread_join`으로 기다리지 않고) 끝나면 알아서 `thread`를 끝내도록 하는 함수.
	- 독립적인 동작을 하는 대신 스레드가 끝나면 '반드시' 자원을 반환해야 하고, `pthread_create`만으로 스레드를 생성하면 routine이 끝나도 자원이 반환되지 않기 때문에 해당 함수 사용.
	- 성공 시 0을 반환하고 실패 시 오류 넘버 반환
	- `pthread_detach`와 `pthread_join`을 동시에 사용하는 것은 불가능.

* 하나의 Thread에서 실행 중인 다른 Thread를 종료하기 위한 함수 :
	- `int pthread_cancel(pthread_t thread);`
	- 인자로 주어진 스레드 식별자 `thread`를 가지는 스레드에게 종료 요청을 보냄.
	- 스레드가 종료 요청을 받았다면 해당 스레드는 `pthread_exit(PTHREAD_CANCELED)`를 수행. 종료시 리턴되는 값은 `PTHREAD_CANCELED`임.

* 생성과 동시에 detach 시키는 방법 : `int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);`

### 3. 스레드 동기화 :

* 스레드를 사용할 때 서로 '동시'에 실행하기 때문에 발생하는 공유자원의 잘못된 접근으로 인해서 문제 발생 가능. 때문에 공유자원을 하나의 스레드만 사용하게 하는 방법 = **동기화**

* 임계 영역(Critical Section)
	- 하나의 스레드만이 진입해야하는 특정 코드 구역, 공유자원의 변경이 일어날 수 있는 구간.
	- 스레드별 값들이 중구난방하게 나오는 경우를 알 수 있고, 이런 경우에 동기화 필요.
	```
	  thread2 cnt:0
	  thread1 cnt:0
	  thread1 cnt:1
	  thread1 cnt:2
	  thread2 cnt:3
	  ...
	```

* 뮤텍스(MutEx)
	- Mutual Exclusion의 약자로 '상호 배제'라고 함. 특정 스레드 단독으로 들어가야 하는 코드 구역에서 동기화를 위해 사용되는 동기화 기법.
	- `pthread_mutex_init` : 뮤텍스를 (동적)초기화하는 방법
	- `pthread_mutex_lock`, `pthread_mutex_unlock` : 뮤텍스를 이용하여 임계 구역을 진입할 때 그 코드 구역을 잠그고 다시 임계 구역이 끝날 때 풀면서 다음 스레드의 진입이 가능하도록 함.
	- `pthread_mutex_destroy` : 뮤텍스를 동적으로 생성했다면, 해당 함수를 사용하여 뮤텍스를 소멸함.
	- 실제로, `lock`과 `unlock`을 critical section 전후에 걸어주는 작업을 진행할 것.

### 4. `ssu_backup` 프로그램 개요

* 쉘을 구현하는 프로그램

* 명령어들을 위한 command 구조체 필요. 각각의 명령어마다 함수 필요.

* 프로그램을 실행 시 지정 경로에 백업 디렉토리 생성
	- `mkdir`을 통해서 디렉토리 생성 or `opendir`로 있는 디렉토리가 백업 디렉토리로 사용
	- 입력받은 디렉토리를 찾을 수 없다? 경로가 잘못되었다 or 있는 디렉토리가 아니다
	- 맥락상 두 가지 모두 후자로 추정. 전자의 경우 생기는 의문점에 대해 여쭤보기

* usage : 현재의 경로 출력? cpu 사용량?

* 프롬프트로 제어가 넘어감 : `ssu_backup` 프로그램 종료

### 5. 로그 파일 기록 개요

- 기존 로그 파일을 사용할 것이 아니기 때문에 헤더 파일 `#include <syslog.h>` 선언 X

- `enum` 등을 사용해서 로그 기록에 대한 구조체를 선언 후 해당 구조체의 형식에 맞게 로그 파일에 기록

- ~~시간의 경우 헤더 파일 `#include <sys/time.h>`를 사용해 `int gettimeofday(struct timeval *tv, struct timezone *tz)` 함수 사용 예정. (CPU 시간만을 재는 `clock`은 측정에 오류가 있을 것으로 판단)~~

- `stat`이라는 함수를 이용해 해당 파일의 정보들을 사용하여 저장하는 방식으로 진행.

- 백업해야 할 파일명 제한에 대해서는 조금 더 찾아보기.

### 6. 백업 개요

- `list`라는 연결리스트에 각 파일들의 정보 저장

- `PERIOD`라는 백업 주기마다 백업을 진행해야 하는 부분. 여기에서 `PERIOD`의 의미에 대해 보충 설명을 들어야. (명령문 1개를 '1'로 여기는지, 시간 1초를 '1'로 여기는지 등)

- `mtime`의 경우 `stat` 함수에서 쓰이는 `stat`에서 가지고 있는 정보들 중 `time_t st_mtime`을 의미.

- `recover` 명령어의 경우 어떻게 구현할지 좀 더 상상해보고 짜볼 필요 O

### 7. 참고적으로 구현에 필요한 함수에 대해 공부

* `pthread_cond_init`, `pthread_cond_destroy`
	- 스레드 1과 스레드 2가 있을 때, 스레드 2는 항상 스레드 1의 값 변동 이후 명령문을 실행하는 조건이 있을 경우에 스레드 2가 스레드 1을 지속적으로 확인 및 감시하는 것이 아니라 특정 조건이 발생했을 때 signal을 보내서 감지할 수 있도록 = 조건 변수 사용
	- `int pthread_cont_init(pthread_cond_t *restrict condition, const pthread_condattr_t *restrict attr)` : 조건 변수를 초기화. `condition`이라는 조건 변수를 초기화하는데 `attr`로 속성을 지정. `NULL`이면 기본 조건 변수 사용.
	- `int pthread_cond_destroy(pthread_cond_t *condition)` : 조건 변수를 삭제하고, 조건 변수에 할당된 자원을 해제. 어떤 스레드도 해당 조건 변수를 기다리고 있으면 안됨.
	- 필요에 의해서 `pthread_cond_wait` 또는 `pthread_cond_siganl`을 사용하는 경우도 생각해야.

* `getopt()`와 `system()`에 대해서 공부 예정.

* * *

210208
------------

## 명세 설명 중 공부

### 0. 명세 공부 중 보충

- `pthread_cond_init`, `pthread_cond_destroy` 등의 명령어는 활용하지 않아도 프로그램 구현 가능.

- `pthread`함수 중 `pthread_detach`와 `pthread_cancel`을 잘 사용할 것.

- usage : 사용 방법을 알려주라는 의미. `Usage : [디렉토리명]` ex) `Usage : ./ssu_backup`

- 생성할 백업 디렉토리를 인자로 넣어주지 않는 경우, 임의의 이름을 가진 백업 디렉토리 생성

- 로그 파일은 파일 입출력을 통해서 `logfile`이라는 것을 만들고 수행.

### 1. 명세 추가 공부

* 로그 파일 기록) 파일명 제한
	- `add` 명령어를 통해 백업해야 할 파일이 추가되면서 백업이 처음으로 이루어지기 때문에 해당 명령어에 파일명 제한 조건을 넣는 것 생각.
	- 1byte = 문자 1개. `strlen`을 통해 나오는 값이 255보다 작거나 같아야 함.

* 백업) `recover` 명령어 구조
	- 로그 파일 내 파일 경로와 인자로 입력한 파일 경로 중 일치하는 경로 찾기
	- 경로가 일치하는 로그들의 정보를 리스트로 띄움. (연결ㄹ스트에서 찾아서) 띄울 때 백업시간 기준 오름차순으로 출력할 것.
	- 만들어진 쉘로 들어오면서 입력한 백업 폴더 내에 있는 파일을 복사해서 덮어 씌우기 or `w` 모드로 열어서 내용 넣기

* system() 함수
	- 헤더 파일로 `#inclue <stdlib.h>`를 선언 후 사용 가능.
	- `int system(const char* command);`
	- Shell 명령어를 실행하기 위한 함수
	- `command`에 지정된 명령어를 실행하며, 명령어가 끝난 후 반환. 리턴된 값은 호출이 실패한다면 127, 다른 에러가 있다면 -1, 그렇지 않으면 명령어의 리턴 코드가 반환.

* 연결리스트 구조
![linkedlist.jpg](./linkedlist.jpg)

* argc, argv 등의 개념
	- argc는 실행 파일과 함께 입력한 인자들의 개수를 카운트
	- argv는 문자열로 저장된 인자의 주솟값을 배열형태로 저장. 공백 단위로 끊어서 인덱스에 하나씩 저장

## 실제 수행 항목

### 1. 헤더 파일 작성

- 구조체 및 필요 함수 선언

### 2. 메인 파일 작성

- 쉘의 기본 구조 작성(첫 입력과 기본 출력)
- linkedlist 구조 구현 중

* * *

210209
--------------

## 명세 공부

### 1. `ssu_backup` 파일 기본

- `pwd` 즉, 현재 경로를 가지고 있는 상태에서 상대 경로가 입력되면 현재 경로를 의미하는 `./`를 덧붙여야 하는가. -> 일단 덧붙여서 진행해보기

- `list`는 연결리스트 내에 존재하는 파일 경로와 period를 출력하면 될 것(연결리스트 노드 구조체 안에 period 부분이 있어야 함)으로 판단.

### 2. 명령어별 명세

* `add`
	- 백업해야 할 파일이 일반 파일인지 확인 -> `stat`에서 파일 유형인 `st_mode`를 확인. regular file을 의미하는 01000001(bit단위 표현) 인지 확인. or 파일의 종류를 체크하는 POSIX macro 사용. 일반 파일 여부인 `S_ISREG(buf.st_mode)` 사용. 뿐만 아니라 디렉토리 등의 여부를 체크하는 데에도 쓸 예정.
	- 백업해야 할 파일이 백업 리스트에 존재하는지 확인하기 위해선 `logfile` 체크
	- 백업 주기마다 해당 파일을 백업하기 위해서 어떤 작업이 필요할지 -> 스레드를 필요할 때마다 만들어주거나 반복문을 때에 맞춰서 만들어주는 작업은 비효율적일 것으로 판단. 리눅스에 있는 `crontab`이란 명령어를 c에 적용할 수 있는지. or `while do sleep done` 명령어를 좀 더 공부해보고 사용 가능한지 판단 예정.

* `remove`
	- 해당 명령어를 통해서 연결리스트 `node`의 삭제까지 진행할 수 있도록 함.

* `system` 함수 사용
	- `system` 함수로 `ls`와 `vi` 명령어를 사용해야 하는 부분을 확인 중. 아직은 어느 부분에서 사용해야할지 감을 못잡음.

## 구현

- `ssu_backup` 파일 실행 시 초기 화면의 조건 구현 중.

* * *

210210
----------------

## 명세 공부

### 1. `ls`, `vi`, `exit` 명령어

- 프롬프트에서 실행 가능한 명령어.

- `ls`, `vi`는 `system`함수와 함께 실행하여 보일 예정. 둘 다 `mkdir`함수로 만든 디렉토리 내에서 진행하면 될 것으로 판단.

- `vi`와 `vim` 모두 적용가능하도록 진행해야 할 것으로 판단.

### 2. `add` 명령어

- 특정 주기를 기준으로 파일을 백업하는 경우, `while`문을 사용해 `sleep`으로 주기 동안 일시 정지할 수 있도록 설정. 이 방법으로 주기를 두고 반복할 수 있도록 설정 가능할 것으로 판단 -> 구현 중 오류를 느끼면 방법을 다시 찾고 변경하기로.

## 구현

### 1. 기본 화면

- `ssu_backup`을 실행하면서 받은 인자들에 대한 조건 설정 완료

- `ssu_backup` 파일을 실행한 쉘에서 받아들인 명령어에 따른 처리 부분 진행 완료

- 디렉토리 이름을 기준으로 배열에 저장하기 위해 사용할 '인덱스' 처리를 어떻게 할지 고민중 -> 0부터 진행하여 `NULL`인 곳에서 저장하는 방법을 생각. 진행하기로 결정.

- 연결리스트에 쓰일 노드 구조체 변수 변경(`period`라는 변수 추가)

### 2. `add` 명령어

- 연결리스트를 위한 노드를 만드는 함수와 배열에 인덱스를 설정하여 파일 이름 및 링크를 설정하는 작업 완료.

- add 명령어 기본 부분의 오류 처리 진행 중.

* * *

210215 공부한 내역
-------------

## 구현

### 1. `add` 명령어

- `PERIOD` 옵션이 실수형으로 입력되었을 때 에러 처리를 진행하는 부분에서, 데이터 타입을 구분할 수 있는 요소가 무엇인지 검색 중. 크기의 경우, `int`와 `float`이 4byte이기 때문에 구분이 불가능할 것이라 판단. 어떠한 방법으로 구분 가능한지 찾는 중. (기존에 찾았던 문자와 정수 구분 방법은 해당하지 않을 것이라 생각)

- 로그 관련 및 위에 작성한 오류를 제외한 `add` 명령어의 예외처리 진행 완료. (예외처리 후 `return` 하는 것은 추후에 추가할 예정)


- 백업 리스트 추가 및 삭제를 진행하는 스레드가 필요하다고 판단했으나 어느 부분에서 스레드를 만들고 진행하는 것이 좋을지 생각 중.(일단은 제외하고 진행)

### 2. 로그 파일

- 로그 파일 구조체 완성. 기존에 생각했던 `enum`의 경우 프로그램에서 값을 변경하는 작업 진행이 어렵기 때문에 `struct`로 진행하고자 함. (로그 파일 내의 로그들을 연결리스트로 진행할 경우 `link` 추가 예정. 일단은 연결리스트로 하고자 했으므로 추가하기로 함.)

- 처음 해당 프로그램이 시작될 때 로그 파일의 유무 판단 및 생성 작업 완료.

- `add` 작업 이후 `logfile`에 반영하는 부분 진행 중 (시간 부분, link 부분 진행해야)

- 시간 부분은 스레드를 사용한 후 적용해야 할 것으로 판단. 스레드를 만드는 부분 생각할 것.

### 3. remove 명령어

- `logfile`을 확인해야하는 예외처리를 제외하고 예외처리 완료. (`add` 명령어와 동일하게 `return`부분 추후에 추가 예정)

* * *

210216
-------------

## 명세 및 조언

### 1. 문자열 입력받기

- `scanf`를 사용하기보다 `fgets` 명령어를 사용하는 것이 좋음 -> 변경 완료.

### 2. 명령어의 예외 조건

- 백업 파일이 백업 리스트에 있는지 확인하는 것은 '로그 파일'을 참고하여 진행하는지 `list` 명령어로 보여주는 목록에서 진행하는지. (일단은 로그 파일을 먼저 만들었기에 로그 파일로 진행.)

### 3. `add` 명령어

- `PERIOD`로 실수가 입력되었는지 확인하는 두 가지 방법 : 문자열로 받은 `PERIOD`에 소수 표현을 위해 필요한 '.'이 있는지 확인하기 또는 1.0으로 나누었을 때 나머지 값이 0인지 아닌지 확인하기 (후자 선택해서 진행)

## 구현

### 1. `add` 명령어

- 백업 리스트에 백업 파일이 있을 경우에 에러 처리를 진행하는 예외처리 완료.

- `list` 명령어를 통해서 확인하기 위한 작업은 아직 진행하지 않음.

### 2. 로그 파일 작성

- 로그 파일 내에 있는 각각의 로그를 작성하는 부분은 함수로 넘어가서 진행하기로 결정. (로그 작성 함수의 경우 수정, 추가, 삭제 등을 나누어서 함수를 만드는 방법으로 진행.)

- 로그 작성 함수 중 추가와 삭제 진행 완료.

- 만들어낸 로그 내용들(연결리스트)를 로그 파일에 넣는 함수 완료.

- 유의할 점 : 시간 부분 제외하고 진행.

### 3. `remove` 명령어

- 백업 리스트에 백업 파일이 있을 경우에 에러 처리를 진행하는 예외처리 완료.

- 연결리스트에서 삭제하는 작업 진행 완료.

* * *

210217
--------------

## 명세 및 조언

### 1. 문자열 합치기

- `strcat`으로 파일의 경로 및 로그 파일 안에 있는 로그들을 `sprintf`를 사용해서 작성하는 것이 더 바람직하다는 조언 반영.

### 2. 수행 및 접근 시간 표현

- `stat` 구조체 내에 존재하는 'time of last access' 를 의미하는 `time_t st_mtime` 또는 `st_atime`을 사용하는 방식은 스레드를 사용하는 방법과 관련이 크지 않을 것이라고 생각. -> `st_mtime`과 같은 방법을 쓰고자 했던 이유는 `compare` 명령에어도 해당 `stat`을 비교하는 것으로 미루어보아 이를 활용해 시간을 알 수 있다고 생각했음.

- 일단은 `clock_gettime`과 `gettimeofday`를 사용하는 방법을 다시 찾아보았지만 대부분 용도가 '실행하면서 걸리는 시간'을 측정하는 것으로 판단. '접근하는 시간'을 측정하기에 적합하지 않을 수도 있다는 생각. 일단 해당 함수들의 사용 방법 및 예시들을 좀 더 상세하게 공부할 것. (`clock`보단 `gettimeofday`가 더 정확한 linux의 시간 값을 가짐. 하지만 `gettimeofday`의 경우 초와 마이크로초를 저장하기에 나에게 필요한 함수인지 의문.)

- 스레드의 주기를 설정(`pthread_wait`)하여 원하는 `PERIOD`를 기준으로 실행할 수 있다는 것 생각하기.

## 구현

### 1. 로그 파일

- `recover` 명령어를 사용했을 때 로그 파일에 쓰일 로그의 내용에 대한 함수 작성 완료.

### 2. `list` 명령어

- `list` 명령어를 쳐서 출력되는 값들은 링크드 리스트의 값들을 출력하기로 결정. (파일 경로와 `period` 두 가지가 출력되면 되기 때문)

- `list` 명령어에 대한 함수 구현 완료.

### 3. `compare` 명령어

- `mtime`과 파일 크기를 비교하는 과정 수행 중.

* * *

210218
-----------

## 명세 설명

### 1. 로그 파일

- 로그 파일에서 특정 명령어(`add`, `recover`, `remove`)를 실행했을 때 등장하는 시간을 나타내기 위해서 `tm` 구조체의 변수들을 사용하면 될 것. -> 지금이 몇 년 몇 월 며칠, 몇 시 몇 분 몇 초인지 의미하는 `tm_year`, `tm_mon`, `tm_mday` 등을 활용해서 로그에 그대로 기록하면 될 것으로 판단. `<time.h>` 헤더파일을 사용.

## 구현

### 0. 현재 경로 넣기

- 로그 파일 및 백업 디렉토리를 만드는 부분에서 `getcwd` 함수를 사용해 현재 디렉토리 경로를 알아내고 앞에 붙이기.

- `getcwd` : `<unistd.h>` 헤더 파일 추가 후 진행. `char *getcwd(char *buf, size_t size);` `buf` = 현재 디렉토리의 절대 경로를 저장할 버퍼 주소, `size` = 버퍼의 크기

### 1. 로그 파일

- `add`, `remove`, `recover` 명령어에 따른 로그에 시간 부분 추가 완료.

- 로그 파일에서 로그 내 파일명이 255바이트를 넘을 경우를 구분하기 위해 인자를 받고 각각 나누는 과정(파일명 등)에서 구분하기로 결정. 배열에 널 문자가 있는지 확인.

### 2. `compare` 명령어

- 에러 처리 및 해당 명령어의 기능 처리 완료.

* * *

210219
--------

## 명세 설명

### 1. 상대 경로

- 상대 경로 -> 절대 경로 변환 가능한 함수 = `realpath`를 사용하는 것을 조언받음.

- `char* realpath(const char *path, char* resolved_path);` 파라미터) `path` = 절대 경로로 변환할 상대 경로나 symbolic link. `resolved_path` = 변환된 절대 경로가 저장될 buffer.

- 현재 진행하고 있는 `getcwd`함수를 사용하는 데에 오류가 생기면 변경해서 진행할 가능성 열어둘 것. 다른 부분에서도 유용하게 쓰일 경우 있을 것으로 판단.

### 2. 백업

- 백업 명령어가 진행될 때, `list` 명령어에 쓰이는 연결리스트와 로그파일에 쓰이는 연결리스트에 적용되는 것 외에 명령어를 실행하면서 쓰인 파일들이 디렉토리에 복사되는 작업 진행 : 파일 용량을 알아보고 크기만큼 동적할당한 배열을 만들고 해당 배열에 복사하는 방법 or 문자 하나하나씩 읽고 똑같은 이름의 파일을 만들어서 넣어주기. 후자 선택해서 진행.

- 쓰일 함수들 : (파일에 문자를 하나하나씩 쓰거나 읽을 때 사용) (`fgets`와 `fputs`로도 가능할 것 같아보임) `fgetc`, `fputc` (상황을 보고 사용 예정. 읽을 문자의 위치 조정) `fseek`

- `fgetc` : `int fgetc(FILE* stream);` `stream` = 접근할 파일 포인터. `EOF`를 반환할 때까지 진행하면 됨.

- `fputc` : `int fputc(int c, FILE* stream);` `c` = 넣을 문자 혹은 숫자. `stream` 다룰 파일의 파일 포인터. 파일에 문자를 넣는 것을 성공하면 해당 문자 반환. 넣는 걸 실패하면 `EOF` 반환.

- `fseek` : `int fseek(FILE* stream, long offset, int whence);` `stream` = 대상 파일. `offset` = 이동할 바이트 수. `whence` = 시작 지점(`SEEK_SET` = 파일의 시작 `SEEK_CUR` = 현재 읽기/쓰기 포인터 위치 `SEEK_END` = 파일의 끝) 반환 = 0을 반환하고 오류가 발생하면 -1을 반환. 만약 사용하게 된다면 현재 위치에서 1씩 건너뛰는 방식으로 진행 가능.

## 구현

### 0. `PERIOD` 반복

- `PERIOD`마다 로그 작성 및 백업 작업 부분을 진행할 때, 파일마다 각각의 스레드를 만들어야 하는지 생각 중.

### 1. 백업

- 백업 디렉토리 내에 같은 파일명으로 저장하기 위해서 진행할 방법 -> `strtok`를 사용해서 '/'를 기준으로 나누는 방법을 생각 중.

- `add` 명령어에 대한 결과 즉, 백업 디렉토리에 백업할 파일을 복사해서 넣어주기 위한 함수 생성 완료. (위에서 언급한 파일명 지정 부분 제외)

- `PERIOD`마다 `add` 명령어에 대한 백업 부분을 반복적으로 진행해야 할지, 또는 다른 새로운 함수를 만들지 생각해보기. -> 일단은 만든 함수를 반복하는 것으로 진행.

- `remove` 명령어에 대한 결과 즉, 백업 디렉토리에 존재하는 명시된 파일을 삭제해주는 함수 생성 완료. (파일명 지정 부분 제외) 백업 디렉토리와 명시한 파일을 비교하는 과정에서 '파일명'만을 기준으로 비교하면 될까? 일단은 파일명 기준 비교 진행. 삭제는 `unlink` 또는 `remove` 함수를 사용하는데, 이 중 `unlink`를 사용하기로 결정.

- `unlink` : `int unlink(const char *pathname);` `pathname` = 삭제할 대상이 될 파일 경로

### 2. `ls` 명령어

- `ls` 명령어를 치면서 함께 입력한 디렉토리를 사용하는 작업 진행 중.

- `readdir`로 디렉토리의 처음부터 파일 및 디렉토리를 읽을 때, 읽혀진 파일명 중 현재 디렉토리를 나타내는 '.' 도 포함되어 있기때문에 무한 반복에 빠지지 않으려면 파일명이 '.' 이거나 '..' 이면 skip 해야 한다고 함. (이 부분은 왜 그런지 좀 더 이론적으로 찾아보기로)

* * *

210220
---------------

## 명세 설명 및 조언

### 1. `remove` 명령어

- 백업 리스트에서 삭제하고 더이상 백업되지 않게 하는 기능 -> 연결리스트에서 삭제 및 `PERIOD`를 기준으로 백업 작업을 진행한 스레드를 종료하는 작업을 해야 함.

- 실제로 `unlink`나 `remove` 명령어를 써서 백업 파일을 없애는 것 의미X

### 2. 백업

- 백업 디렉토리에 백업할 대상의 파일과 같은 파일을 복사하기 위해서 '파일명'이 같아야 함 -> 백업 디렉토리의 절대 경로를 미리 저장해놓고 `sprintf`를 사용해서 저장 가능.

- 파일명만 추출하기 위해서 `strrchr` 함수를 사용할 수 있을 것으로 판단. 경로의 뒤에서부터 '/'라는 찾고자 하는 요소를 찾은 결과로 파일명이 나올 것. `char *strrchr(const char *s, int c);` -> 다음에 진행할 때 코드 모두 확인하면서 필요한 부분에 전부 적용하기.

### 3. `ls` 명령어

- `system` 사용해서 진행하면 됨.

### 4. `recover` 명령어 에러 처리 정리

- 변경할 파일이 존재하지 않으면 에러 처리 -> 입력한 인자 `FILENAME`이 존재하는 파일인지 확인

- 변경할 파일에 대한 백업 파일이 존재하지 않으면 에러 처리 -> 백업 파일에 대한 연결리스트를 확인하거나 백업 디렉토리 내에 파일이 존재하는지 확인. `remove` 명령어를 실행했을 때 백업 파일에 대한 연결리스트에서 백업 파일이 삭제되기 때문에, 이를 감안해서 후자로 진행하기로 결정. (유의할 점 | `recover` 명령어의 명세 중 '변경할 파일이 현재 백업 리스트에 존재한다면 백업 수행 종료 후 복구 진행'은 지금까지 이야기했던 것과 별개의 내용)

## 구현

### 1. `remove` 명령어

- `remove`나 `unlink` 명령어를 사용하는 부분을 제거. 추후에 스레드를 사용할 때, 스레드를 종료하는 명령어를 사용할 예정.

- 스레드 생성 시 저장된 스레드 아이디를 저장하고 스레드 아이디(인자로 주어지는 `pthread_t thread`)에 해당하는 스레드를 종료하는 방향으로 진행 가능할 것으로 생각 -> 각각의 스레드 아이디를 연결리스트 노드마다 저장해야 할 수도 있다는 점을 유의할 것. 스레드 부분을 진행할 때 참고해서 진행하자.

### 2. `ls` 명령어

- 상대 경로를 입력받았을 경우 내부적으로 변경해주는 작업 완료.(`realpath` 사용)

- 경로를 입력받아서 `system` 명령어까지 진행 완료.

### 3. `vi(m)` 명령어

- 상대 경로를 입력받았을 경우 내부적으로 변경해주는 작업 완료.

- 경로를 입력받아서 `system` 명령어까지 진행 완료.

### 4. `recover` 명령어

- 변경할 파일이 현재 백업 리스트에 존재할 수 있기 때문에 백업 리스트인 `Linklist* head`를 확인 진행 -> 추후에 백업 수행 종료 부분을 추가할 예정.

- 백업 파일이 존재하지 않는 경우 = 백업 디렉토리에 백업된 파일이 존재하지 않는 경우. 파일명을 기준으로 찾아내고자 함. `strrchr` 사용할 것.

- 변경할 파일이 존재하지 않는 경우 에러 처리 완료.

### 2와 3의 경우 재확인한 결과 함수로 넘어오는 과정에서의 파일경로 인자가 이미 절대경로로 넘어왔을 것으로 판단. 추후 수정 예정.

* * *

210222
----------------

## 명세 설명

### 1. `recover` 명령어

- 로그에 있는 파일 및 파일에 대한 정보들을 이용하여 진행해보거나 연결리스트로 보여주는 내용에 따른 파일의 정보(파일의 크기)를 담기 위해서 스레드를 활용해야 한다고 생각. 스레드에서 add 및 여러 가지 수집되는 정보마다 새로운 연결리스트를 만들어서 파일을 각각 저장해야 하는 방법으로 진행해야 하는지 고민.

- 만약 상단에 설명한 방법 중 후자로 진행하게 된다면, `recover` 명령어를 입력했을 때 등장하는 리스트는 파일명마다 존재하는 연결리스트를 출력하는 방식으로 진행해야 함.

### 2. 스레드

- 스레드 생성 부분에서 스레드 id를 어떻게 생성할지. 스레드를 저장할 스레드 배열에서 인덱스 값을 매번 주는 방식은 X -> 어떤 방식으로 인덱스를 줄 것인지 고민.

## 구현

### 0. 함수 및 호출 인자

- 상대 경로로 입력된 경우 절대 경로로 바꿔주는 과정을 함수를 호출하기 전에 진행했기 때문에, 함수 내에서 절대 경로로 변경하는 작업을 없애도 무관 -> 수정 완료.

### 1. `recover` 명령어

- 변경할 파일에 대한 백업 파일이 존재하지 않는 경우의 예외 처리 완료 -> 백업 디렉토리 내에 있는 파일명으로 진행. 리스트 형태로 출력해야 하는 것과 별도로 진행함.(예외처리 = 백업 디렉토리 내의 파일명. 리스트 형태 출력 = 로그 파일 내 파일명 비교)

- 리스트 형태로 백업시간 기준 오름차순 출력 -> 로그 파일 내에 존재하는 로그들의 내용을 비교해서 출력. 오름차순의 경우 이미 로그가 시간 순서대로 되어있기 때문에 그대로 출력하면 될 것이라 판단. (로그로 작성되기 전 명령어들마다 동시다발적인 작업을 처리해주는 뮤텍스의 역할이 중요할 것으로 생각)

- 로그를 활용하는 방법으로 진행했을 때, 실제파일을 변경해주는 작업은 진행이 힘들다고 생각. 명세 설명으로 썼던 방법 중 후자의 방법으로 진행할 방법 생각하기. (스레드 이용 및 연결리스트 생성)

### 2. 스레드

- 전역변수로 스레드를 각각 저장할 스레드 배열 선언.

- 명령어에 따른 스레드 생성 진행. `add` 명령어에서 `pthread_create` 명령어 생성 진행 중. 스레드 함수로 `thr_func`라는 함수를 만들고 해당 함수에 쓰일 인자로 `head`를 넘김.

- `add` 명령어를 진행하는 함수 내에서 파일을 복사하는 작업을 함수로 만든 `Copy` 함수가 스레드 함수인 `thr_func`에서 진행되도록 변경하고자 함 -> 그럴 경우에 `Copy` 함수에서 쓰이는 인자들도 같이 넘어가야 하는 부분을 어떻게 해결할지 알아보기.

* * *

210223
-----------

## 명세 설명 및 조언

### 1. `recover` 명령어

- 백업 디렉토리에서 특정 파일을 찾아서 해당 파일로 변경하는 작업을 진행할 때, 백업 디렉토리의 파일명과 비교하는 방식으로 진행 가능 (파일명 뒤에 붙는 시간 부분을 이용할 것)

### 2. 스레드

- 스레드 생성 시 필요한 스레드 id : 스레드 함수에서 `pthread_self()` 함수를 사용해 연결리스트에 있는 `tid` 값에 넣어주기. `pthread_t pthread_self(void)` = 현재 스레드의 id를 얻을 수 있음. 연결리스트에 `tid` 값을 넣을 수 있도록 설정해야 함.

- 나중에 `remove` 명령어를 진행할 때는, 연결리스트에 접근해 `tid`를 얻고 `pthread_cancel()` 함수를 실행하는 방식으로 진행.

- `pthread_create`를 진행하면서 스레드 함수에 여러 가지 인자를 넘겨주고 싶을 때, 여러 인자를 가지고 있는 구조체를 선언해주고 해당 구조체를 `(void*)`로 캐스팅해서 전달해줌.

## 구현

### 1. 백업 디렉토리

- 백업 디렉토리에 파일을 추가 및 수정해 저장할 때, 해당 파일에 접근하는 시간을 파일명 뒤에 붙여서 저장할 수 있도록 변경 완료. (작업을 초반에 진행할 때 해당 부분을 생각하지 못했기 때문에 나중에 전체적으로 검토하면서 수정을 이어서 진행하기)

### 2. 스레드

- `pthread_create` 과정에서 스레드 함수에 쓰일 인자를 위해서 `Factor`라는 구조체 생성 완료.

- 파일을 일정 `period`를 기준으로 반복해서 복사하는 스레드 함수 생성 완료.

- 연결리스트의 노드에 `t_id`라는 스레드의 id를 저장하는 인자 추가. 스레드를 만들고 나서 해당 인자에 스레드의 id를 저장. (여기에서 스레드 id를 저장할 변수 하나를 만들면, 매번 새롭게 저장할 때마다 스레드의 id가 달라지는가? -> 달라짐)

### 3. `remove` 명령어

- `pthread_cancel` 함수를 사용해서 특정 스레드 중단. 하지만 이 과정에서 작업을 종료 후 스레드를 중단해야 한다면 `join` 등의 함수를 사용해야 함. 일단은 사용하지 않고 진행 완료.

### 4. `recover` 명령어

- 지정한 파일의 백업 파일 목록을 보여주는 함수 진행 중.

* * *

210224
----------

## 명세 설명

### 1. `recover` 명령어

- 리스트를 보여준 뒤 리스트에 해당하는 번호들을 입력받고 파일명을 알 수 있어야 하기 때문에 연결리스트 형태로 파일명 뒤에 위치한 날짜와 리스트의 넘버링을 담는 방법 또는 `sprintf`를 이용해서 넘버링과 함께 뒤의 문자열들을 연결한 후 넘버링과 온점을 합친 문자열을 포함한 문자열을 찾는 방법 중 선택해서 진행. 후자로 먼저 진행하기로 결정.

### 2. `exit` 명령어

- 프롬프트에 `exit`을 적었을 때의 작업 처리와 `recover` 명령어 내 0번에 위치한 `exit`을 선택했을 때의 작업이 동일한 것인지 알아보기.

- `pthread_exit` 함수 사용. `pthread_join`에 쓰이는 매개변수 `rval_ptr` 을 사용하여 진행하기 때문에 `pthread_join` 함수를 사용해야 할 것으로 판단. 반납할 값이 얼마인지 확인하고 이후에 프로그램을 종료할 수 있도록 진행하는 방향 생각.

### 3. 뮤텍스

- 스레드별 값들이 나오는 로그 파일에서 필요한 부분. 스레드마다 로그 파일에 새로이 값이 만들어지기 전과 후에 `lock`과 `unlock`을 걸어주는 과정 필요.

### 4. 스레드 함수

- 스레드 함수 내에서 로그 파일에 로그를 작성하는 함수를 진행해야 할 것으로 판단. 처음엔 `add` 부분이, 이후에는 `generated`가 작성되는 로그와 관련된 함수들을 실행하도록 해야 함. -> 이럴 경우 로그에 대한 연결리스트가 필요 없어질 것으로 판단. 현존하는 로그 관련 함수들을 모두 수정해야 함.

## 구현

### 1. `recover` 명령어

- 백업 디렉토리 내에 있는 백업 파일들을 보여주는 함수 구현 완료. (파일명 중 날짜 부분은 `_` 라는 구분자를 기준으로 나누었고, 파일의 크기는 `stat` 활용.

- 리스트를 보여주고 백업 파일의 날짜 부분만 추출하는 부분 구현 완료.

- 백업 디렉토리 내에 해당하는 파일로 변경하는 작업을 나타내는 함수 생성 진행 중.

- exit을 선택했을 때 작동하는 함수 생성 중.

### 2. `remove` 명령어

- 초기에 백업 디렉토리에 영향을 미친다고 생각하고 만들었던 `Delete` 함수 삭제. 스레드에 영향을 미치는 `pthread_cancel` 함수로 대체.

### 3. 로그

- 스레드에서 로그를 생성하는 함수들을 호출하기 위해서 현존하는 로그 관련 함수들을 수정 진행 중.

* * *

210225
----------

## 명세 설명

### 1. `recover` 명령어

- `pthread_exit`의 조건이 `exit`을 명령어로 입력하거나 `recover` 명령어에서 `exit`을 선택해야 진행됨. 이 부분에 대한 조건 즉, `pthread_exit`을 실행할 조건을 어떻게 설정할지 생각 중.

- `pthread_exit` 함수를 `recover` 명령어에서 진행하기 위해 해당 함수 내에서 `pthread_create`를 실행하지 않고도 `pthread`를 선언하기만 하고 진행 가능한지 알아보기 -> `join` 등에서 쓰이는 인자가 필요하기 때문에 해당 부분에서 진행 가능한지.

## 구현

### 1. 로그

- `added`와 `generated`, `deleted`에 따른 로그 함수 작성 완료. 기존에 있던 로그 함수 수정.

### 2. 스레드 함수

- 스레드 함수 내에서 종료 시 `pthread_exit` 함수를 사용하기 위해서 `pthread_join` 함수를 `Add` 함수 내에 선언.

- `pthread_exit` 함수를 스레드 함수 내에서 실행. 특정 조건에 따라서 발생해야 함. 특정 조건 부분 작성 중.

### 3. `recover` 함수

- `recover` 함수를 사용해서 기존 파일을 변경하는 임의의 함수 생성 완료.

### 4. 뮤텍스

- 뮤텍스를 초기화하는 `pthread_mutex_init` 함수를 스레드 생성 및 뮤텍스를 사용하는 스레드 함수 전에 실행.

- 스레드 함수의 로그를 작성하는 부분의 반복문 앞뒤로 뮤텍스의 `lock` 과 `unlock` 작성 완료.

- 스레드 종료와 동시에 뮤텍스를 동적으로 생성한 것을 없애기 위해서 `pthread_mutex_destroy` 함수 사용.

* * *

210226
-------------

## 명세 설명 및 조언

### 1. `recover` 명령어

- 스레드를 종료하는 작업을 `recover` 명령어에서 진행하기 위해서 해당 함수 내에서 `pthread_create`를 진행하지 않고도 작업 가능한가 -> `pthread_cancel` 함수를 사용해서 끄는 작업 가능 -> 모든 스레드 작업을 종료하려면 `head`를 이용해서 `t_id` 변수를 스레드 id로 이용해 종료하면 될 것으로 판단.

## 구현

### 1. `recover` 함수

- `recover` 함수에서 선택지 0번인 `exit`을 선택하면 `pthread_cancel` 함수가 실행되도록 설정. `head`가 변경되면서 `head`가 `NULL`일 때까지 해당 함수 실행하도록 설정 완료.

### 2. 스레드 함수

- 스레드 함수 내에 존재했던 `pthread_exit`함수의 조건을 설정하고자 했던 부분 삭제. `exit` 명령어가 들어오면 `pthread_cancel`을 진행하는 방식으로 설정. 변경 완료.

### 3. `exit` 명령어

- 해당 명령어를 쉘에서 받았을 때 수행할 함수 생성 완료.

### 4. 컴파일

- 오류 수정 중. 현재 250번 줄 즈음 진행 중.

* * *

210227
----------

## 명세 설명

### 1. 명령어 내 오류에 대한 처리

- 에러 처리를 위해서 에러라는 것을 출력하여 아린 후 함수의 `return` 값인 특정 변수(`int`)가 0인지 1인지를 통해서 앞으로 반복해서 쉘을 진행할 것인지 여부를 결정하고자 함 -> 이 과정에서 연결리스트인 `head`를 저장하려면 함수의 리턴형이 `Linklist*`인 함수가 존재하기에 `int`형으로 받을 수 있는지 의문. `Linklist*`가 리턴형인 함수에서 `null`을 리턴할 경우에 조건문을 사용 가능한지 알아보기.

## 구현

### 1. `recover` 함수

- 리스트에서 특정 번호를 선택했을 때 해당 파일의 내용을 출력하는 부분 완성.

### 2. 명령어 내 오류 처리

- `return` 값에 오류 처리에 알맞은 값을 작성 중.

### 3. 컴파일 오류 처리

- 320번째 줄 처리 중.

- `period`가 실수인지 확인하는 부분을 `(float)(atoi(option[0])) % 1.0` 또는 `((float)atoi(option[0])) % 1.0`을 진행했으나 오류 발생. 해결 중..

* * *

210228
------------

## 명세 설명 및 조언

### 1. 명령어 내 오류 처리

- 리턴형이 `Linklist*`가 아니어도 적용 가능. 특정 명령어에 쓰이는 파라미터에 주소를 넘기면 사용 가능. 함수가 종료되어도 반영. ex) `void add(Linklist **head);`

- `int`형으로 리턴해서 앞으로의 쉘 반복 여부를 결정하고 `head`는 함수가 종료해도 반영될 수 있도록 변경하기.

### 2. 컴파일 에러 처리

- `(float)atoi(const char *string)` 방식을 사용해서 정수형으로 변경 후 실수형으로 바꾸는 방식이 아니라 `atof(const char *string)` 함수를 사용해서 변경 가능.

- `strrchr` 함수 사용법 : 특정 문자열에 함수를 사용한 값을 저장하는 것이 아니라 `char*` 즉, 포인터에 저장.

## 구현

### 1. 명령어 내 오류 처리

- `Linklist`를 변경하는 작업을 요구하는 명령어의 함수(`Add`와 `Remove`, `Recover`, `Exit` 등)를 수정. 에러 처리 후 프롬프트로 제어가 넘어가거나 프로그램이 종료되는 작업 수행.

### 2. `recover` 명령어

- 변경할 파일이 현재 백업 리스트에 존재하는 경우, 스레드를 종료하고 진행하는 부분 완료.

### 3. 컴파일 에러 처리

- 600번째 줄 진행 중.

* * *

210301
---------

## 명세 설명

### 1. 컴파일 에러 처리

- `int mkdir(const char *pathname, mode_t mode)` : 헤더파일 = `<unistd.h>`. 반환 값으로는 성공하면 0, 실패하면 -1을 리턴.

- `mode` : 생성 시 설정할 디렉토리에 대한 접근 권한을 설정하는 값. 설정값은 `umask` 설정값과 `exclusive` or 연산 결과값이 설정됨. Owner와 그룹에 대한 읽기, 쓰기, search 권한을 모두 설정하고, Other에 대한 읽기와 search에 대한 권한 설정 => `0775`로 설정.

- `ssu_backup` 파일을 실행했을 때 인자로 받은 디렉토리의 접근 권한이 없는 경우 즉, `search`가 불가능한 경우에 프로그램 종료. 접근 권한을 `0001` / `01111` 이상인 경우에 실행이 가능하도록 진행. 일단 전자로 진행하고자 함.

- `ssu_backup` 파일을 실행하면서 백업 디렉토리를 입력받기 위해서 사용되는 `argv`의 경우, 메인 함수 내에서 접근하려면 `argv[0]`으로 접근하기.

- 스레드 함수에서 함수가 종료될 때 `return;`을 사용하지 않음 (사용했을 때 오류가 발생했고, 이 부분에 대해서 예제 코드들을 찾아본 결과 `return`을 사용하지 않는 것 확인함)

## 구현

### 1. 컴파일 에러 처리

- 전체적으로 한 번 에러 검수 후 수정 완료.

- 이후에 다시 컴파일 진행해보고 나온 오류들 수정 진행 중. (line : 480)

* * *

210302
----------

## 명세 설명 및 조언

### 1. 컴파일 에러 처리

- `double`형의 나머지 구하기 : `fmod` 함수 사용. `double fmod(double x, double y)`. 헤더 파일 = `<math.h>`, `x` = 나누어지는 수 `y` = 나누는 수. 반환되는 값 = 나눈 나머지

### 2. 컴파일

- `math.h` 헤더 파일을 사용하기 때문에 `-lm`을 같이 써주고 thread를 사용하기 때문에 `-lpthread`를 함께 쓰면서 컴파일 진행.

## 구현

### 1. 컴파일 에러 처리

- 컴파일 에러 수정 완료. (2차 완료) -> 컴파일 완료

### 2. 메인 함수

- 잘못된 디렉토리명으로 디렉토리가 생성되는 오류 확인. `argv`가 `@`인 것 확인. 수정 진행 중.

* * *

210303
--------

## 명세 설명

### 1. 파일 수정

- `argv` : `argv[0]`은 항상 실행 경로가 들어가는 부분. 때문에, 백업 디렉토리를 작성한 부분에 접근하고 싶다면 `argv[1]`을 접근해야 함.

- 접근 권한 : 파일 권한을 알 수 있는 함수 `access`를 사용하는 방법 생각. `stat`에서 쓰이는 `mode_t`를 활용한 디렉토리의 접근 권한을 `int`형으로 출력했을 때, 이상한 숫자(`16983` 등)가 나오는 것 확인. 때문에, 이러한 방법을 시도해보는 것 진행.

- `access` : `int access(const char *pathname, int mode);` 헤더 파일 = `<unistd.h>` `pathname` = 체크하고자 할 디렉토리 또는 파일명, `mode` = 적절한 마스크 값. `mode` 변수에 들어갈 수 있는 `mask` 값 = `R_OK`, `W_OK`, `X_OK`, `F_OK`. 결고 값은 `int`형으로 성공하면 `0`을, 실패하면 `-1`을 반환. 디렉토리의 접근 권한 = 실행 권한이라고 생각.
러
- 실행 권한으로 진행했을 때, 권한 오류 발생. 확인 결과, 만든 디렉토리에는 `x` 권한이 없고 `r` 권한은 있는 것으로 확인. 디렉토리의 접근 권한 = 읽기 권한으로 생각하고 진행.(혹시 이 부분에서 조언해주실 수 있다면 조언 부탁드려요.. 제가 혹시나 권한을 끼워맞춘 게 되어버린 것 같습니다)

- `add` 명령어를 구현하는 부분에서 에러 처리와 관련된 명령어 등장. 원인 = 경로를 찾았을 때 딕셔너리의 경우 딕셔너리 명에 `/`가 붙을 것이라고 생각했으나 붙지 않았기 때문. 이 부분은 경로에서 `/`를 추가하는 것으로 대책 마련. 해당 명령어 이외에도 경로를 사용하는 부분에서 `/`를 추가 진행.

## 구현

### 1. 파일 에러 처리

- `add` 명령어를 진행했을 때 백업 리스트에 존재하는 파일이라고 인식. 이 부분 해결 진행 중.

* * *

210305
-------------

## 명세 설명 및 조언

### 1. 에러 처리

- `add` 명령어의 `do while`을 사용해서 `dic` 배열의 비어있는 공간을 찾는 과정에서 세그멘테이션 오류 발생 => 배열 내에서 경로를 저장하는 부분이 비어있는 지 확인하는 것을 `dic[idx].dir == NULL`로 확인하는 방식으로 변경.

- 배열(`dic`)에서 경로를 저장할 공간에 `strcpy`를 사용해서 배열을 저장하는 부분에서 세그멘테이션 오류 발생. 배열의 크기를 다루어서 해결해보고자 했으나 해결 X. 경로를 미리 저장한 공간의 데이터 확인 결과 이상 무. => 배열 `dic`을 포인터로 선언했기 때문인 것으로 확인.

- 배열 `dic`의 효율적인 사용 X => 제거하는 방향으로 진행. 이외에 백업 디렉토리의 경로를 효율적으로 사용하기 위해서 전역으로 해당 경로를 저장하여 사용하는 방법 추진 및 진행.

- 존재하는 디렉토리를 백업 디렉토리로 사용 가능. 이 부분에 알맞게 수정 진행해야 함.

## 구현

### 1. 에러 처리

- `add` 명령어 구현 부분에서 명령어 입력 잘 작동 완료. 명령어 입력 후 세그멘 테이션 오류 발생 -> 오류 발생 부분 해결.

- `ls`, `vi` 명령어 실행에 오류 없음 확인.

- `exit`의 경우 프롬프트가 종료되고 돌아가는 것은 확인이 가능했으나, 스레드를 강제 종료하고 돌아가는 것인지는 아직 확인 불가능.

- `compare` 명령어의 에러 처리 및 명령어 실행에 오류 없음 확인.

- `Diclist`를 선언 및 활용하는 부분 삭제 진행 중.(삭제 후 실행되지 않는 부분들 확인 중)

- 백업 디렉토리 경로 저장하는 전역변수 선언 및 활용 완료.

* * *

210306
---------

## 명세 설명 및 조언

### 1. 뮤텍스

- 뮤텍스를 이용해 임계구역을 진입할 때 코드 구역을 잠그고 푸는 `pthread_mutex_lock`, `pthread_mutex_unlock`으 로그를 작성할 때마다 `lock`과 `unlock`을 진행해야 함.

## 구현

### 1. 뮤텍스

- `pthread_mutex_lock`고 `pthread_mutex_unlock` 위치 변경 완료.

### 2. 에러 수정

- 백업 디렉토리의 경로를 저장할 배열의 요소 중 `null`을 체크하는 구간에서 오류 발생 => 2차원 배열을 사용해서 백업 디렉토리의 경로를 모두 저장하고자 했던 부분 수정. `ssu_backup` 파일을 실행했을 때 입력한 백업 디렉토리의 경로만 저장하도록 변경.

### 3. 스레드 함수

- `Add` 명령어에서 스레드를 생성하는 데에서 그치는 것이 아니라 명령어를 실행하는 함수 내에서도 스레드에서 돌아가고 있는 동일한 함수를 호출. 스레드 함수를 호출해야 함. 이 부분 진행 완료.

- 스레드 함수 내에서 세그멘테이션 오류 발생. `pthread_mutex_lock`을 진행하면서 오류가 나는 것 판단 => 뮤텍스 초기화 위치를 백업을 진행하는 함수 내로 변경. => 백업 진행 함수 내에서 세그멘테이션 오류 발생. (파일을 읽고 새로 여는 부분에서 생기는 오류로 판단. 수정 진행 중)

* * *

210307
----------

## 명세 설명 및 조언

### 1. 뮤텍스

- 뮤텍스 초기화의 두 가지 방법 :
	* mutex 선언고 동시에 초기화 = `PTHREAD_MUTX_INITIALIZER` 사용하기.
	* `pthread_mutex_init` 사용하기.

## 구현

### 1. 뮤텍스

- 뮤텍스를 초기화하는 방법으로 `pthread_mutex_init`을 사용하기보다 초기에 `mutex`를 선언하면서 초기화해주는 방법으로 진행 완료.

- 뮤텍스를 `pthread_mutex_init`을 사용해서 초기화하지 않았기 때문에 `pthread_mutex_destroy` 함수가 필요 없을 것으로 판단. 삭제 완료.

### 2. 에러 처리

- 디렉토리의 접근 권한 설정을 변경하면서 세그멘테이션 오류 수정 완료. '0775'로 권한 부여.

### 3. 스레드

- `add`에서 구현한 스레드 함수 작동 부분에서 오류가 있는 것으로 판단. `add`에 대한 작업이 진행되면서 프롬프트 화면이 등장해야 하는데, `add`에 대한 작업이 진행되기만 함.

- `pthread_create`함수와 `pthread_join` 함수를 호출한 위치에 따라서 스레드 작업과 별개의 작업으로 진행될 내용이 달라질 것으로 판단. 일단 두 함수를 호출하는 위치를 변경해보기로 결정.

- `pthread_join` 위치 변경) 기존에 진행했던 위치 : `Add` 명령어를 위한 함수 내. 변경해본 위치 : 메인의 명령 프롬프트 화면 호출 반복문 뒤. `Add` 명령어에 대한 함수를 호출하고 난 후. => 변경 후의 결과에 변동이 없었기 때문에 다시 원상 복구.

- `pthread_create`에 쓰이는 인자까지 위치를 변경하는 과정에서 `head`의 위치 등도 변경해야 하기 때문에 일단 보류. 다른 스레드 함수 및 스레드 예제 등 찾아보는 중.

### 4. 로그 파일

- `logfile`에도 파일 추가 등으로 인해 생기는 로그들이 추가되지 않는 것 확인. 이에 대한 부분 수정 진행 예정.
